import { Test, TestingModule } from '@nestjs/testing';

const CDPSessionMock = {
  send: jest.fn(),
};

const TargetMock = {
  createCDPSession: jest.fn().mockImplementation(() => CDPSessionMock),
};

const PageMock = jest.fn().mockImplementation(() => ({
  close: jest.fn(),
  target: jest.fn().mockImplementation(() => TargetMock),
  goto: jest.fn(),
  setUserAgent: jest.fn(),
}));

const BrowserMock = jest.fn().mockImplementation(() => ({
  close: jest.fn(),
  newPage: jest.fn(),
}));

const PuppeteerMock = {
  launch: jest.fn(),
  use: jest.fn(),
  Page: PageMock,
  Browser: BrowserMock,
};

jest.mock('puppeteer', () => PuppeteerMock);
jest.mock('random-useragent');
jest.mock('puppeteer-extra-plugin-adblocker');
jest.mock('puppeteer-extra-plugin-stealth');

import puppeteer from 'puppeteer-extra';
import { Browser, Page } from 'puppeteer';
import randomUseragent from 'random-useragent';
import { PuppeteerService } from './puppeteer.service';
import { EDomContentLoaded, ENetworkProtocols } from './enums';
import { UA } from './constants/index';

describe('PuppeteerService', () => {
  let service: PuppeteerService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PuppeteerService],
    }).compile();

    service = module.get<PuppeteerService>(PuppeteerService);
  });

  afterEach(() => jest.clearAllMocks());

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('#createBrowser - should generate a new instance of a browser with adblockers and plugins actived', async () => {
    const expectedBrowser = new Browser();
    const useSpy = jest.spyOn(puppeteer, 'use').mockReturnValue({} as any);
    const launchSpy = jest
      .spyOn(puppeteer, 'launch')
      .mockResolvedValue(expectedBrowser);

    const result = await service.createBrowser();

    expect(result).toBeDefined();
    expect(result).toEqual(expectedBrowser);
    expect(launchSpy).toHaveBeenCalled();
    expect(useSpy).toHaveBeenCalledTimes(2);
  });

  describe('#goToPage', () => {
    let browser: Browser;
    let page: Page;
    let newPageSpy: jest.SpyInstance;
    let gotoSpy: jest.SpyInstance;
    let setUserAgentSpy: jest.SpyInstance;
    const params = {
      url: 'www.fillikenes.com',
    };

    beforeEach(() => {
      page = new Page();
      browser = new Browser();
      gotoSpy = jest.spyOn(page, 'goto').mockResolvedValue({} as any);
      setUserAgentSpy = jest
        .spyOn(page, 'setUserAgent')
        .mockResolvedValue({} as any);
      newPageSpy = jest.spyOn(browser, 'newPage').mockResolvedValue(page);
    });

    it('should redirect to an url from a new page generated by the browser given as argument, no random useragent', async () => {
      const result = await service.goToPage({
        browser,
        url: params.url,
        setRandomUA: false,
      });

      expect(result).toBeDefined();
      expect(setUserAgentSpy).toHaveBeenCalledWith(UA);
    });

    it('should redirect to an url from a new page generated by the browser given as argument, set random useragent', async () => {
      const expectedUA = 'TEST-USER-AGENT';
      const getRandomSpy = jest
        .spyOn(randomUseragent, 'getRandom')
        .mockReturnValue(expectedUA);

      const result = await service.goToPage({
        browser,
        url: params.url,
        setRandomUA: true,
      });

      expect(result).toBeDefined();
      expect(getRandomSpy).toHaveBeenCalled();
      expect(setUserAgentSpy).toHaveBeenCalledWith(expectedUA);
    });

    afterEach(() => {
      expect(newPageSpy).toHaveBeenCalled();
      const [gotoUrlParam, gotoPropertiesParam] = gotoSpy.mock.lastCall;
      expect(gotoUrlParam).toEqual(params.url);
      expect(gotoPropertiesParam).toHaveProperty(
        'waitUntil',
        EDomContentLoaded.Domcontentloaded,
      );
    });
  });

  it('#closeBrowser - should execute the close process for a browser given as argument', async () => {
    const browserParam = new Browser();
    const closeSpy = jest
      .spyOn(browserParam, 'close')
      .mockResolvedValue({} as any);

    await service.closeBrowser(browserParam);

    expect(closeSpy).toHaveBeenCalled();
  });

  it('#clearCookies - should send events to clear cookies associated with a page given as argument', async () => {
    const pageParam = new Page();
    const clientSessionSendSpy = jest
      .spyOn(CDPSessionMock, 'send')
      .mockResolvedValue({} as any);

    await service.clearCookies(pageParam);

    expect(clientSessionSendSpy).toHaveBeenCalledTimes(2);
    const [firstCall, secondCall] = clientSessionSendSpy.mock.calls;
    expect(firstCall[0]).toEqual(ENetworkProtocols.Cookies);
    expect(secondCall[0]).toEqual(ENetworkProtocols.Cache);
  });

  it('#closePage - should execute the close process for a page given as argument', async () => {
    const pageParam = new Page();
    const closeSpy = jest
      .spyOn(pageParam, 'close')
      .mockResolvedValue({} as any);

    await service.closePage(pageParam);

    expect(closeSpy).toHaveBeenCalled();
  });
});
